# FailSafe (MythologIQ/FailSafe)

**Intent Service:** The Intent Service manages *governance intents* in the workspace. It maintains a single “active intent” at a time in PULSE status, tracks its metadata, and enforces status transitions. The `IntentService` class can **create** a new intent (assigning it an ID, type, purpose, and initial “PULSE” status), **record evidence** for it, update its status (e.g. to PASS/REJECT), and finally **seal** it when approved【105†L25-L33】【105†L68-L77】. All changes are logged to an intent history (for audit). In code, attempts to create a new intent will fail if there’s already an active intent that isn’t SEALED【105†L25-L33】. Thus, the Intent Service enforces the lifecycle of a governance action: create intent → gather evidence → (optionally update status) → seal intent or block it. 

**L3 Risk Classification:** Risk levels (L1/L2/L3) are determined by pattern-matching on file paths or content. The `PolicyEngine` class loads a JSON policy (`risk_grading.json`) containing lists of **L3 triggers** for file paths and content. In `classifyRisk()`, it checks if the file’s normalized path contains any L3 trigger substring – if so it returns “L3”【113†L97-L105】. It also scans file content for any configured L3 keywords (e.g. “DROP TABLE” from the example)【113†L104-L111】. If no L3 triggers match, it then checks for L2 triggers similarly【113†L113-L122】. In short, **any match of a high-risk keyword** in the path or content causes L3 classification; otherwise it may fall back to L2 or L1 according to defaults【113†L97-L105】. 

**Sentinel Audits:** Sentinel is a background daemon that continuously monitors the workspace for file changes. It uses a file watcher (via [chokidar](https://npmjs.com/package/chokidar)) to watch all workspace files (ignoring node_modules, .git, .failsafe, etc.)【118†L207-L215】. On every file add/change/delete, Sentinel **queues an event**. An internal loop (`processEvents`) takes events from the queue and processes them one-by-one via `processSingleEvent()`【120†L310-L318】. For each event, Sentinel calls the `VerdictArbiter` to **evaluate the event** and produce a *verdict*, then passes that verdict to `VerdictRouter.route` to enforce it【120†L310-L318】【120†L325-L328】. (For example, a verdict might block the change or allow it.) The history, actions, and audit outputs of Sentinel are then recorded. In sum, Sentinel “performs audits” by automatically watching for changes, arbitrating risk/confidence (possibly involving LLM or heuristics), and routing the verdict (logging or blocking)【120†L310-L318】.

**SOA Ledger Structure:** The **SOA Ledger** is an append-only, Merkle-chained audit log implemented on SQLite. The `LedgerManager` creates a table `soa_ledger` with columns capturing every relevant event field: timestamp, event type, agent DID, trust score, model version, file path/hash, risk grade, verdict details, etc., plus cryptographic fields【122†L25-L33】【122†L112-L131】. Notably it stores `entry_hash`, `prev_hash`, and `signature` for each row, chaining entries cryptographically. On initialization, if empty, it inserts a **genesis entry**. Each ledger entry’s `entry_hash` is computed (via SHA-256) from the event data and the previous hash, and then signed with a workspace key【122†L25-L33】【122†L174-L183】. This ensures the ledger is tamper-evident. In practice, every enforcement or verification action writes a new row to this ledger; over time it forms an audit trail of all decisions, secured by chained hashes and signatures【122†L25-L33】【122†L112-L131】.

**Claude Code Integration:** FailSafe includes **Claude-specific command workflows** alongside its other agent integrations. In the workspace root, there is a `.claude/commands/` directory with Claude Code command markdown files (e.g. `.claude/commands/agents/ql-technical-writer.md`)【126†L18-L25】. These define the prompts/flows when using Claude CLI. The documentation notes that Claude capabilities have been “folded into” the Antigravity and VS Code extensions (meaning the same skills can be invoked via UI or CLI)【102†L119-L123】. Enforcement is unified: *all* write actions (whether triggered by VS Code, Gemini, or Claude Code) pass through the same QoreLogic/Enforcement engine. As the CLAUDE.md file states: “Follow the rules in `.claude/commands/...`. All writes are subject to EnforcementEngine (FailSafe Extension)”【123†L0-L3】. In other words, the Claude Code commands simply live in the workspace under `.claude/` and use the same policy/ledger pipeline as the other interfaces.

# AgentMesh and Agent OS (External Repositories)

*(The following sections summarize AgentMesh and Agent OS based on their published documentation and code, for cross-comparison. These repos were not part of the user’s connected sources, so citations refer to their GitHub.)*

**AgentMesh – Reward Engine:** AgentMesh’s reward engine computes multi-dimensional trust scores per agent. When you call `engine.get_agent_score(agent_id)`, you get an object containing a total trust score plus individual “dimension” scores (e.g. policy_compliance, resource_efficiency, etc.)【91†L608-L627】. The engine continuously updates these scores based on agent actions. Under the hood (`agent-mesh/reward/engine.py`), it maintains a history of observed behavior and weights each action according to configurable metrics. In summary, trust is not a single static score but a vector of factors that feeds into a combined trust rating. 

**AgentMesh – Delegation Chains:** AgentMesh supports hierarchical delegation. In the system, any agent can *delegate* authority to a sub-agent, but the sub-agent’s scope is always a subset of the parent’s scope【128†L7-L15】. The architecture shows a `delegation.py` module for “Delegation chains”【128†L12-L21】. Operationally, the parent’s identity signs a delegated identity (e.g. using SPIFFE certificates) that restricts what actions the delegate can perform. The README states: “Agents can delegate to sub-agents, but scope always narrows”【128†L7-L14】. This means delegation is cryptographically enforced: the system’s Trust Bridge recognizes that the sub-agent’s permissions are contained within the parent’s, preventing privilege escalation.

**AgentMesh – MCP Proxy (Tool Calls):** AgentMesh provides an MCP (Model-API) proxy that intermediates all agent tool calls. In practice, you launch tools via `agentmesh proxy`, and that proxy transparently adds trust enforcement. The README example shows how an agent’s tool command (e.g. file I/O) is replaced by `agentmesh proxy` with policy flags【91†L528-L537】【91†L553-L562】. All intercepted calls are then audited or blocked according to configured policies. Under the hood, the proxy likely wraps calls and routes them through AgentMesh’s event loop: each call is treated like a governance event. The result is that *without changing the agent code*, you get automatic policy enforcement and logging on every tool invocation.

**AgentMesh – Compliance Frameworks:** AgentMesh includes built-in mapping for several compliance standards. The documentation explicitly lists support for **EU AI Act, SOC 2, HIPAA, and GDPR**【91†L438-L445】. These frameworks are encoded as policy templates: for example, there are rules that enforce PHI protections and audit logging for HIPAA, or data subject rights workflows for GDPR. A ComplianceEngine module generates compliance reports or enforces rules corresponding to these standards. In short, AgentMesh ships with compliance frameworks as first-class policies (automating controls needed for each listed standard)【91†L438-L445】.

**AgentMesh – IATP Handshake:** The Inter-Agent Trust Protocol (IATP) in AgentMesh is implemented as a sidecar protocol (leveraging Agent OS). To initiate communication, two agents perform a handshake that verifies their DIDs and trust scores. The AgentMesh SDK provides a `TrustBridge.verify_peer(peer_id, required_trust_score)` method which checks another agent’s identity and ensures its trust score exceeds the threshold【91†L590-L599】. In the source, IATP functionality is backed by the Agent OS (there is an `iatp/` module using agent-os)【95†L7-L15】. Essentially, when an agent claims something (via Agent OS), the Sentinel or trust bridge in AgentMesh can call `validateClaim(claim)` to have Agent OS arbiter check it. Thus, IATP ensures both sides agree on identity and trust before proceeding. 

**Agent OS – Kernel Interception:** Agent OS provides a lightweight “kernel” (Python middleware) that intercepts and validates all agent actions. In use, an agent calls `kernel.execute(agent_id, "some action")` instead of invoking LLM or APIs directly. The kernel’s policy engine then decides whether to allow it【93†L1-L4】. The README explicitly shows that any dangerous query (like `DROP TABLE`) is blocked by the kernel before being sent to the database【93†L1-L4】. Under the hood, Agent OS offers SDK adapters for OpenAI, LangChain, etc., so that API calls are rerouted through `agent_os.kernel`. This mimics an OS: before any LLM/tool call runs, it passes through the Agent OS policy checker【93†L19-L24】【93†L37-L40】. 

**Agent OS – VFS Structure:** Each agent has a virtual file system (VFS) with standard POSIX-like paths. The VFS includes `/proc` and `/tmp`, as well as memory-backed directories such as `/mem/working` and `/mem/episodic`【98†L25-L28】. Agents can read/write these via the `AgentVFS` API: for example, `vfs.write("/mem/working/task.txt", "something")` or `vfs.read("/policy/rules.yaml")`【94†L13-L22】. The file paths in the schema (like those in [94†L7-L15]) show how memory and file I/O are sandboxed. This VFS isolates each agent’s context: only allowed paths are accessible, and any access goes through the kernel’s checks.

**Agent OS – Cross-Model Verification (CMVK):** CMVK is Agent OS’s multi-LLM consensus mechanism. It allows the kernel to run multiple LLM completions for the same prompt and compare them. The documentation notes that CMVK “achieves consensus across LLMs”【95†L19-L22】. While implementation details are in code (the `cmvk/` submodule), the concept is that for critical outputs, the kernel can demand agreement among multiple models before trusting the result. (For example, if three models produce the same answer, confidence increases.) CMVK is an extension that can be enabled via pip (`agent-os[cmvk]`)【95†L25-L28】. 

**Agent OS – POSIX-Style Signals:** Agent OS supports POSIX-like signals for controlling agents. The `SignalDispatcher` class can send `SIGSTOP`, `SIGCONT`, and `SIGKILL` to an agent by its ID【98†L33-L40】. For example, calling `dispatcher.signal(agent_id, AgentSignal.SIGSTOP)` pauses the agent, and `AgentSignal.SIGKILL` force-terminates it. The architecture diagram calls out “Signal Dispatch” as part of the kernel’s control plane【98†L19-L27】. These signals mirror traditional OS signals (pause, resume, kill) and are implemented in the kernel as special actions that can preempt or resume agent execution.

**Agent OS – Flight Recorder:** The Flight Recorder is Agent OS’s audit log. It records every action to a local SQLite database. The README describes it as “SQLite-based audit logging”【99†L7-L14】. Each action results in an append to the log table, similar to an airplane’s black box. However, the documentation warns this is not cryptographically tamper-proof: because it’s SQLite, a compromised agent could potentially modify it【99†L12-L14】. The recommended mitigation is to export logs to an external sink for critical audits. In summary, the Flight Recorder provides persistent audit history (via SQLite), but with known limitations on immutability【99†L7-L14】.

# Cross-Repository Integration

- **QoreLogic (FailSafe) with IATP (AgentMesh):** Without explicit adapters, integration is speculative. In theory, QoreLogic could issue DIDs for agents and tag governance actions with those IDs. AgentMesh’s IATP requires a mutual DID handshake with trust verification. If QoreLogic exported agent identities in a compatible format (e.g. DID+verifiable proofs), AgentMesh’s TrustBridge could validate them. However, no code in the available sources directly connects FailSafe intents with AgentMesh trust protocols. This remains an open integration question.

- **Agent OS Kernel running FailSafe logic:** In principle, the FailSafe extension (TypeScript) and its QoreLogic logic could be invoked from Agent OS via the CLI (if exported), but they are different ecosystems (VSCode/TypeScript vs Python). No bridge exists out-of-the-box. Agent OS’s kernel expects Python-callable actions, whereas FailSafe’s enforcement is a VS Code extension. Significant work (e.g. implementing a Python wrapper around FailSafe’s logic) would be needed to make Agent OS run FailSafe’s intent checks.

- **Audit Systems Comparison:** FailSafe’s SOA Ledger, AgentMesh’s Merkle audit log (referred to in its docs), and Agent OS’s Flight Recorder all aim at immutable audit trails. The SOA Ledger (SQLite with chained hashes) is the most elaborate, providing cryptographic chaining and signatures【122†L25-L33】【122†L112-L131】. AgentMesh claims a Merkle-based log (not shown here), which likely uses blockchain/hash trees. Agent OS’s Flight Recorder is simpler (SQLite, no chaining)【99†L7-L14】. A formal comparison would evaluate tamper-evidence and performance of each. As-is, the SOA Ledger provides a stronger cryptographic guarantee than Agent OS’s log, and the Merkle approach (AgentMesh) could potentially offer distributed verifiability. 

- **Reward Engine scoring FailSafe intents:** AgentMesh’s reward engine is designed for trust-scoring agent behavior, while FailSafe’s QoreLogic deals with human-provided governance intents. There is no standard interface for feeding an intent into AgentMesh. However, one could imagine treating each decision (allow/block) as an “agent action” and scoring it. Without a shared API, this would require custom integration.

- **Common Policy Language:** The systems use different policy approaches. FailSafe uses JSON policies (e.g. risk_grading.json) and code rules. AgentMesh uses whatever configuration for its compliance engine. Agent OS uses programmable rules (via its kernel and possibly YAML for agent configuration). They do not share a common DSL. Converging to one policy language would require defining a superset or translation layer (for example, mapping FailSafe’s risk triggers to Agent OS policies). This is not provided by the existing code.

**Unresolved Gaps:** We have uncovered how each system functions individually, but direct integration points are not implemented in the provided code. For example, FailSafe’s extension code does not call into AgentMesh or Agent OS. No connectors (APIs or adapters) exist for QoreLogic ↔ IATP or kernel. The biggest gaps are at the interfaces: translating actions/intents across systems. Further work would involve designing APIs (REST, RPC, CLI) so one system can subscribe to the other’s events, or adopting common identity formats. Additionally, running Agent OS on FailSafe code would require a language bridge. These would be next investigative steps.

**Sources:** The above information is drawn from the FailSafe repository (IntentService【105†L25-L33】, PolicyEngine【113†L97-L105】, SentinelDaemon【118†L207-L215】【120†L310-L318】, LedgerManager【122†L25-L33】【122†L112-L131】, and CLAUDE docs【123†L0-L3】) and from the public AgentMesh/Agent OS repos (readme and code as cited above). Each cited source corresponds to code or documentation lines that reveal the implementation. 

